Привет. Буду отмечать проделанную работу по названию файла. 

event_datamart: 

Комментарий: 

"Актуальный город следует искать не по дистанции, а по дате. 
После того, как ты проставишь города всем событиям, тогда можно оконной функцией пронумеровать события 
для каждого пользователя по убыванию даты сообщения и взять первую строку. 
Это будет последним событием пользователя, а значит оно совершено в текущем городе." 

Не отрабатывает правильно. Сгруппировал по event_id (присвоил id событиям), после пробовал просто по event группировать. 
Код следующий: 

df = df.select('event', 'event_type', 'zone_id', 'city', 'distance')
df = df.join(df.select('event', 'distance').groupBy('event').agg(F.min('distance')), 'event')

windowSpec = Window.partitionBy("event").orderBy(F.desc("event.message_ts"))
df = df.withColumn("row_number", F.row_number().over(windowSpec))
df = df.filter(df.row_number == 1)
df = df.drop("row_number")

Получаю результат: 
+--------------------+----------+-------+------+------------------+------------------+
|               event|event_type|zone_id|  city|          distance|     min(distance)|
+--------------------+----------+-------+------+------------------+------------------+
|[,,,, I am cluele...|   message|      1|Sydney|3249.3559469241245|123.69524556016147|
|[,,,, I want to c...|   message|      1|Sydney| 818.8055684612121| 117.9386835158272|
|[,,,, \ is used t...|   message|      1|Sydney| 827.1614129516836| 90.17066571265514|
|[,,,, agreed,, 28...|   message|      1|Sydney|166.35085026972382| 84.45974261524132|
+--------------------+----------+-------+------+------------------+------------------+

Там ни по event.datetime, ни по event.message_ts не реализовать. Поэтому оставляю сравнение distance и min(distance). 

